<!DOCTYPE html>
<html lang="zh-CN">
  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="description" content="常红达的个人博客">
  <meta name="keywords" content="">
  
    <link rel="icon" href="http://img2.ph.126.net/T5EUfn4iMZCILs9MDPuSvA==/6597839424798151772.png">
  
    
  <title>2018年你应该了解的前端新技术 | 常红达的博客</title>
  <link rel="stylesheet" href="/style.css">
  <link rel="stylesheet" href="/lib/jquery.fancybox.min.css">
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
</head>

<body>
  <header>
  <div class="header-container">
    <a class='logo' href="/">
      <span>常红达的博客</span>
    </a>
    <ul class="right-header">
      
        <li class="nav-item">
          
            <a href="/" class="item-link">首页</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/about" class="item-link">关于</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/archives" class="item-link">归档</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/tags" class="item-link">标签</a>
          
        </li>
      
    </ul>
  </div>
</header>

  <main id='post'>
  <div class="content">
    <article>
        <section class="content markdown-body">
          <h1>2018年你应该了解的前端新技术</h1>
          <div class='post-meta'>
            <i class="fa fa-calendar" aria-hidden="true"></i> <time>2018年01月21日</time>
            
              | <i class="fa fa-folder-open-o" aria-hidden="true"></i> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/js/">js</a>
  </div>



            
            
              | 
                  <i class="fa fa-tag" aria-hidden="true"></i>
                
               
  <a href="/tags/#js" class='tag'>js</a>


            
          </div>
          <h4 id="一、HTML5-2新标签dialog"><a href="#一、HTML5-2新标签dialog" class="headerlink" title="一、HTML5.2新标签dialog"></a>一、HTML5.2新标签dialog</h4><p>HTMl5.2新的版本出现了一个有意思的标签，那就是对话窗或窗口，也就是<code>dialog</code>,其基本用法如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dialog open&gt;</span><br><span class="line">    //soming...</span><br><span class="line">&lt;/dialog&gt;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>open</code>属性表明该窗口是默认显示的，用户可与之交互。<br>相关js方法有：<br>1.<code>close()</code>:关闭对话框，可选传入类型为{domxref(“DOMString”)}}的参数，用来更新对话框的returnValue。<br>2.<code>open()</code>:非模式化的显示这个对话框, 即：打开这个对话框之后依然可以和其他内容进行交互。 可选传入类型为<code>Element</code>或者<code>MouseEvent</code>的参数，用来定义对话框的显示位置。<br>3.<code>showModal()</code>:模式化的显示这个对话框， 并且将会至于所有其他对话框的顶层（屏蔽其他对话框的交互）。 可选传入类型为<code>Element</code>或者<code>MouseEvent</code>的参数， 用来定义对话框的显示位置。<br><code>show()</code>和<code>showModal()</code>是有区别的，<code>show</code>只是显示<code>dialog</code>,而<code>showMadal()</code>是会屏蔽其他的弹出层。<br>按<code>ESC</code>可以关闭<code>dialog</code>，<code>dialog</code>需要重新定义<code>css</code>样式，毕竟本身<code>css</code>是默认的样式。<br>下面是一个demo代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 创建一个dialog --&gt;</span><br><span class="line">&lt;dialog&gt;</span><br><span class="line">    &lt;h1&gt;这是dialog的标题&lt;/h1&gt;</span><br><span class="line">    &lt;div&gt;这是dialog的内容&lt;/div&gt;</span><br><span class="line">    &lt;button id=&quot;close_dialog&quot;&gt;关闭&lt;/button&gt;</span><br><span class="line">&lt;/dialog&gt;</span><br><span class="line">&lt;button id=&quot;open_dialog&quot;&gt;打开&lt;/button&gt;</span><br><span class="line">&lt;!-- js代码 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var dialog = document.getElementsByTagName(&quot;dialog&quot;)[0],</span><br><span class="line">        openDialog = document.getElementById(&quot;open_dialog&quot;),</span><br><span class="line">        closeDialog = document.getElementById(&quot;close_dialog&quot;);</span><br><span class="line">    openDialog.onclick = function()&#123;</span><br><span class="line">        dialog.showModal();</span><br><span class="line">    &#125;;</span><br><span class="line">    closeDialog.onclick = function()&#123;</span><br><span class="line">        dialog.close();</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="二、Grid布局全新的css网站布局"><a href="#二、Grid布局全新的css网站布局" class="headerlink" title="二、Grid布局全新的css网站布局"></a>二、Grid布局全新的css网站布局</h4><p>CSS Grid 布局由两个核心组成部分是 wrapper（父元素）和 items（子元素）。 wrapper 是实际的 grid(网格)，items 是 grid(网格) 内的内容。下面是一个 wrapper 元素，内部包含6个 items ：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;wrapper&quot;&gt;</span><br><span class="line">    &lt;div&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;2&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;3&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;4&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;5&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;6&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>要把 wrapper 元素变成一个<code>grid(网格)</code>，只要简单地把其 <code>display</code> 属性设置为<code>grid</code>即可：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.wrapper&#123;</span><br><span class="line">    displau:grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了使其成为二维的网格容器，我们需要定义列和行。让我们创建3列和2行。我们将使用<code>grid-template-row</code>和<code>grid-template-column</code>属性。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.wrapper&#123;</span><br><span class="line">    display:grid;</span><br><span class="line">    grid-template-columns:100px 100px 100px;</span><br><span class="line">    grid-template-rows:50px 50px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>正如你所看到的，我们为<code>grid-template-columns</code>写入了 3 个值，这样我们就会得到 3 列。 我们想要得到 2 行，因此我们为 <code>grid-template-rows</code>指定了2个值。<br>这些值决定了我们希望我们的列有多宽（ 100px ），以及我们希望行数是多高（ 50px ）,结果如下：<br><img src="http://newimg88.b0.upaiyun.com/newimg88/2017/12/1_fJNIdDiScjhI9CZjdxv3Eg.png" alt="我是图片"><br>接下来是如何在 grid(网格) 上放置 items(子元素) 。特别注意，这里才是体现 Grid 布局超能力的地方，因为它使得创建布局变得非常简单。<br>我们使用与之前相同的 HTML 标记，为了帮助我们更好的理解，我们在每个 items(子元素) 加上了单独的 class ：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;wrapper&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;item1&quot;&gt;1&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;item2&quot;&gt;2&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;item3&quot;&gt;3&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;item4&quot;&gt;4&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;item5&quot;&gt;5&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;item6&quot;&gt;6&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>现在，我们来创建一个 3×3 的 grid(网格)：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.wrapper &#123;</span><br><span class="line">    display: grid;</span><br><span class="line">    grid-template-columns: 100px 100px 100px;</span><br><span class="line">    grid-template-rows: 100px 100px 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将得到以下布局：<br><img src="http://newimg88.b0.upaiyun.com/newimg88/2017/12/1_WxIT0z8OH7-rkoFMg5fwRw.png" alt="3*3布局"><br>不知道你发现没有，我们只在页面上看到 3×2 的 grid(网格)，而我们定义的是 3×3 的 grid(网格)。这是因为我们只有 6 个 items(子元素) 来填满这个网格。如果我们再加3个 items(子元素)，那么最后一行也会被填满。</p>
<p>要定位和调整 items(子元素) 大小，我们将使用<code>grid-column</code>和 <code>grid-row</code>属性来设置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.item1 &#123;</span><br><span class="line">    grid-column-start: 1;</span><br><span class="line">    grid-column-end: 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们在这里要做的是，我们希望 item1 占据从第一条网格线开始，到第四条网格线结束。换句话说，它将独立占据整行。 以下是在屏幕上显示的内容：<br><img src="http://newimg88.b0.upaiyun.com/newimg88/2017/12/1_he7CoAzdQB3sei_WpHOtNg.png" alt="布局图片"><br>如果你不明白我们设置的只有 3 列，为什么有4条网格线呢？看看下面这个图像，我画了黑色的列网格线：<br><img src="http://newimg88.b0.upaiyun.com/newimg88/2017/12/1_l-adYpQCGve7W6DWY949pw.png" alt="布局网格线"><br>请注意，我们现在正在使用网格中的所有行。当我们把第一个 items(子元素) 占据整个第一行时，它把剩下的 items(子元素) 都推到了下一行。<br>最后，给你一个更简单的缩写方法来编写上面的语法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.item1 &#123;</span><br><span class="line">    grid-column: 1 / 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了确保你已经正确理解了这个概念，我们重新排列其他的 items(子元素) 。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.item1 &#123;</span><br><span class="line">    grid-column-start: 1;</span><br><span class="line">    grid-column-end: 3;</span><br><span class="line">&#125;</span><br><span class="line">.item3 &#123;</span><br><span class="line">    grid-row-start: 2;</span><br><span class="line">    grid-row-end: 4;</span><br><span class="line">&#125;</span><br><span class="line">.item4 &#123;</span><br><span class="line">    grid-column-start: 2;</span><br><span class="line">    grid-column-end: 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以下是页面上的布局效果：<br><img src="http://newimg88.b0.upaiyun.com/newimg88/2017/12/1_QDSybpxjXSat6UtoHgUapQ.png" alt="布局效果"></p>
<h4 id="三、Parcel：超快的Web应用打包器"><a href="#三、Parcel：超快的Web应用打包器" class="headerlink" title="三、Parcel：超快的Web应用打包器"></a>三、Parcel：超快的Web应用打包器</h4><p>虽然 webpack 带来了许多可配置性，同事也造就了它的复杂性。 而 Parcel 带来简单性。 官方号称 Parcel 为 “零配置” ，开箱即用。</p>
<p>正如上面所说的 – Parcel 内置了一个开箱即用的开发服务器。 开发服务器将在你更改文件时自动重新构建你的应用程序，并支持<code>模块热替换</code>以实现快速开发。<br>Parcel 有什么好处？<br>1.快速打包 – Parcel 比 Webpack，Rollup 和 Browserify 更快。<br>2.Parcel 支持 JS、CSS、HTML、资源文件等等 – 无需插件 – 更加便于用户使用。<br>3.零配置。开箱即用的代码拆分，模块热替换，CSS 预处理器，开发服务器，缓存等等；<br>4.更加友好的错误日志。<br>我们应该什么时候使用 Parcel ， Webpack 或 Rollup 呢？<br>这完全取决于你，但我个人会在以下情况下使用每个打包器：<br>Parcel：中小型项目（代码行小于 15k）<br>Webpack：大型以及企业级项目。<br>Rollup：用于 NPM 包。<br>让我们给 Parcel 一个机会 。<br>Parcel官网地址：*<a href="https://parceljs.org/" target="_blank" rel="noopener">https://parceljs.org/</a></p>
<h4 id="四、PWA是否能带来新一轮大前端技术洗牌？"><a href="#四、PWA是否能带来新一轮大前端技术洗牌？" class="headerlink" title="四、PWA是否能带来新一轮大前端技术洗牌？"></a>四、PWA是否能带来新一轮大前端技术洗牌？</h4><p>渐进式网络应用 ( Progressive Web Apps )，即我们所熟知的 PWA。<br>自 2015 年以来，PWA 相关的技术不断升级优化，在用户体验和用户留存两方面都提供了非常好的解决方案。PWA 可以将 Web 和 App 各自的优势融合在一起：渐进式、可响应、可离线、实现类似 App 的交互、即时更新、安全、可以被搜索引擎检索、可推送、可安装、可链接。<br>PWA 不是特指某一项技术，而是应用了多项技术的 Web App。其核心技术包括 App Manifest、Service Worker、Web Push、Credential Management API ，等等。其核心目标就是提升 Web App 的性能，改善 Web App 的用户体验。<br>下面我们详细地看一下这些核心技术，是否能够真正弥补 Web 劣势。</p>
<ol>
<li>Web App Manifest<blockquote>
<p>Web App Manifest 是为了解决用户留存问题而诞生的，它是一个外链的 JSON 文件，在这个文件中，像浏览器暴露了站点的名称，地址，图标等等元数据。在浏览器中通过 <link rel="manifest" href="/manifest.json"> 引入这个 JSON 文件，浏览器识别到这个文件的存在，会根据自己的机制决定是否弹出添加到桌面对话框，并在桌面上生成一个应用的图标，通过点击桌面图标进入应用具有沉浸式的体验，全屏显示，没有浏览器地址栏，并且还会自动添加应用启动画面。</p>
</blockquote>
</li>
<li>Service Worker<blockquote>
<p>Service Worker 是一个特殊的 Web Worker，独立于页面主线程运行，它能够拦截和处理网络请求，并且配合 Cache Storage API，开发者可以自由的对页面发送的 HTTP 请求进行管理，这就是为什么 Service Worker 能让 Web 站点离线的原因。</p>
</blockquote>
</li>
<li>Push Notification<blockquote>
<p>Push Notification 其实是两个 API 的结合， Notification API 和 Push API 。<br>Notification API 提供了开发者可以给用户发送通知的能力，包括申请显示通知权限，发起通知，以及定制通知的类型等等。<br>Push API，则是让服务器能够向用户发送离线消息，即使用户当前并没有打开你的页面，甚至没有打开浏览器。</p>
</blockquote>
</li>
</ol>
<p>各家浏览器厂商在 2017 年开始大力支持 PWA,连苹果都已经在几个月前悄悄的进行了 Service Worker 的开发了，iOS 也将支持 PWA。各大站点纷纷实践，用 PWA 已成趋势。</p>

        </section>
    </article>
    
        
  </div>
  <aside>
    
    <div class="toc-container">
        <h1>目录</h1>
        <div class="content">
            <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#一、HTML5-2新标签dialog"><span class="toc-number">1.</span> <span class="toc-text">一、HTML5.2新标签dialog</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二、Grid布局全新的css网站布局"><span class="toc-number">2.</span> <span class="toc-text">二、Grid布局全新的css网站布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#三、Parcel：超快的Web应用打包器"><span class="toc-number">3.</span> <span class="toc-text">三、Parcel：超快的Web应用打包器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#四、PWA是否能带来新一轮大前端技术洗牌？"><span class="toc-number">4.</span> <span class="toc-text">四、PWA是否能带来新一轮大前端技术洗牌？</span></a></li></ol>
        </div>
    </div>
    
  </aside>
</main>



  <footer>
  <div class="copyright">
    <div>
      &copy; 2018 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a>&nbsp
    </div>
    <div>
      Theme by <a href="https://github.com/lewis-geek/hexo-theme-Aath" target="_blank">Aath</a>
    </div>
  </div>
</footer>


<script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script src="/lib/in-view.min.js"></script>
<script src="/lib/lodash.min.js"></script>
<script>
  var isDown = true
  var oldY = 0
  inView.offset(50)

  document.body.addEventListener('touchstart', function(){});
  
  window.addEventListener('scroll', _.throttle(e => {
    var currentY = window.scrollY
    if((oldY - currentY) < 0) {
      isDown = true
    } else {
      isDown = false
    }
    oldY = currentY
  }, 250))

  $("article img").each(function() {
      var strA = "<a data-fancybox='gallery' href='" + this.src + "'></a>";
      $(this).wrapAll(strA);
  });

  $('.toc-link').each(function() {
      var href = $(this).attr("href");
      
      inView(href).on('exit', () => {
        if (isDown) {
          handleActive(href)
        }
      })

      inView(href).on('enter', () => {
        if (!isDown) {
          handleActive(href)
        }
      })

      this.onclick = function(e) {
        var pos = $(href).offset().top - 10;
        $("html,body").animate({scrollTop: pos}, 300);
        setTimeout(() => {
          handleActive(href)
        }, 350)
        return false
      }
  })

  function handleActive(href) {
    document.querySelectorAll('.toc-link').forEach(elm => {
      elm.classList.remove('active')
    })
    document.querySelector(".toc [href='"+ href +"']").classList.add('active')
  }
</script>
<script src="/lib/jquery.fancybox.min.js"></script>


</body>
</html>
