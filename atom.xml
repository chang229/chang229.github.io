<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>常红达的博客</title>
  
  <subtitle>编程中我们会遇到多少挫折？表放弃，沙漠尽头必是绿洲！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="chang229.github.io/"/>
  <updated>2018-03-21T06:31:36.623Z</updated>
  <id>chang229.github.io/</id>
  
  <author>
    <name>常红达</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue项目开发过程中遇到的一些问题总结</title>
    <link href="chang229.github.io/2018/03/21/Vue%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>chang229.github.io/2018/03/21/Vue项目开发过程中遇到的一些问题总结/</id>
    <published>2018-03-21T06:09:30.000Z</published>
    <updated>2018-03-21T06:31:36.623Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、使用vue-cli搭建项目"><a href="#一、使用vue-cli搭建项目" class="headerlink" title="一、使用vue-cli搭建项目"></a>一、使用vue-cli搭建项目</h4><p>1.安装vue-cli:安装好node，直接全局安装vue-cli:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g vue-cli</span><br></pre></td></tr></table></figure></p><p>安装完成后，使用<code>vue-V</code>查看是否安装成功<br><img src="https://images2015.cnblogs.com/blog/1059788/201701/1059788-20170106125052316-34797974.png" alt="查看vue版本号"><br>如果提示“无法识别 ‘vue’ ” ，有可能是 npm 版本过低，可以使用 npm install -g npm 来更新版本。<br>2.生成项目：首先进入到项目目录中，执行命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue init webpack Vue-Project</span><br><span class="line">//其中webpack是模板名称，Vue-Project是自定义的项目名称</span><br></pre></td></tr></table></figure></p><p>命令执行之后，会在当前目录生成一个以该名称命名的文件夹：<br><img src="https://images2015.cnblogs.com/blog/1059788/201701/1059788-20170106133950378-145408144.png" alt="vue-cli创建项目"><br>配置完成之后，通过命令：<code>cd Vue-Project</code>进入项目目录，使用npm安装相关依赖<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure></p><p>启动项目：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure></p><p>如果浏览器打开之后，没有加载出页面，有可能是本地的 8080 端口被占用，需要修改一下配置文件 config&gt;index.js<br><img src="https://images2015.cnblogs.com/blog/1059788/201701/1059788-20170106135204409-1735535107.png" alt="vue配置文件修改"><br>修改完成之后，项目就算已经搭建成功，可以开始编写自己的代码啦。</p><h4 id="二、vue-js程序启动运行时，遇到Unexpected-tab-character问题"><a href="#二、vue-js程序启动运行时，遇到Unexpected-tab-character问题" class="headerlink" title="二、vue.js程序启动运行时，遇到Unexpected tab character问题"></a>二、vue.js程序启动运行时，遇到Unexpected tab character问题</h4><p>在vuejs程序启动时，会遇到一种常见问题，在终端报错：Unexpected tab character。如下图：<br><img src="http://img.blog.csdn.net/20170614091540917?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHZrZWxseQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="vue项目启动报错"><br>解决方法：<br>在eslint的配置文件中（.eslintrc）rules项中添加一行：”no-tabs”:”off”，如下图：<br><img src="http://img.blog.csdn.net/20170614092226463?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHZrZWxseQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="vue报错解决方法"></p><h4 id="三、v-for-列表数据渲染完后如何重新渲染"><a href="#三、v-for-列表数据渲染完后如何重新渲染" class="headerlink" title="三、v-for 列表数据渲染完后如何重新渲染"></a>三、v-for 列表数据渲染完后如何重新渲染</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select class=&quot;dept_select select-change&quot; data-placeholder=&quot;请选择&quot; style=&quot;width: 180px;&quot; name=&quot;academys&quot; id=&quot;academys&quot; data-rule-required=&quot;true&quot; v-model=&quot;Academyselect&quot;&gt;</span><br><span class="line">        &lt;option v-for=&quot;item in academyList&quot; v-bind:value=&quot;item.id&quot;&gt;</span><br><span class="line">            &#123;&#123; item.academyName &#125;&#125;</span><br><span class="line">        &lt;/option&gt;</span><br><span class="line"> &lt;/select&gt;</span><br></pre></td></tr></table></figure><p> 当option列表渲染完成之后，如果数据改变需要重新渲染列表，解决方案为：</p><blockquote><p>把academyList替换为新数组。官网文档以下两种数据变化vue无法检测:1.通过索引修改值;2.改变数组长度。赋值新数组不属于以上两种，有数据改变，就会有更新，记得在对应vue实例中定义academyList:[]这个数组，然后方法中赋值this.academyList就可以。</p></blockquote><h4 id="四、vue中src实现数据绑定遇到的问题"><a href="#四、vue中src实现数据绑定遇到的问题" class="headerlink" title="四、vue中src实现数据绑定遇到的问题"></a>四、vue中src实现数据绑定遇到的问题</h4><p> 在vue2中，src实现数据绑定稍不留神就不成功。假定value.src是绑定的数据。<br>常见错误写法1：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;value.src&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>错误之处在于：<br>1.属性值数据绑定应该用v-bind，应该写成v-bind:src=””<br>2.直接用引号”value.src”会报错，取不到值。<br>常见错误写法2：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;&#123;&#123;value.src&#125;&#125;&quot;&gt;</span><br></pre></td></tr></table></figure><p>常见错误写法3：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;&#123;value.src&#125;&quot;&gt;</span><br></pre></td></tr></table></figure><p>以上均会报错。正确写法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img :src=&quot;value.src&quot;&gt;</span><br></pre></td></tr></table></figure><h4 id="五、vue页面中的定时器或者滚动事件报错"><a href="#五、vue页面中的定时器或者滚动事件报错" class="headerlink" title="五、vue页面中的定时器或者滚动事件报错"></a>五、vue页面中的定时器或者滚动事件报错</h4><p>当vue项目中的组件被移除后，组件中的定时器和页面滚动事件并不会跟随组件一起移除掉，因此会导致出现一些错误，或影响其它组件的正常运行。<br>因此离开该页面需要移除这个监听的事件,<code>destroyed</code>在组件移除后执行。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">destroyed () &#123;</span><br><span class="line">  window.removeEventListener(&apos;scroll&apos;, this.handleScroll)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="六、vue中使用定时器时this指向问题"><a href="#六、vue中使用定时器时this指向问题" class="headerlink" title="六、vue中使用定时器时this指向问题"></a>六、vue中使用定时器时this指向问题</h4><blockquote><p>箭头函数中的this指向是固定不变（定义函数时的指向），在vue中指向vue;<br>普通函数中的this指向是变化的（使用函数时的指向），谁调用的指向谁。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">created () &#123;</span><br><span class="line">    setInterval(() =&gt; &#123; console.log(this) &#125;, 1000) // 箭头函数中this指向vue</span><br><span class="line"></span><br><span class="line">    setInteval(function () &#123; console.log(this) &#125;, 1000) // 普通函数中this指向window,因为setInterval()函数是window对象的函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在vue的定时器函数中如果要使用普通函数，要使用了一个变量来当中间值：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ready: function()&#123;</span><br><span class="line">    let self = this;</span><br><span class="line">    setInvertal(function()&#123;</span><br><span class="line">        for(let k in self.goods_list)&#123;</span><br><span class="line">            .......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="七、vue-router-页面切换后保持在页面顶部而不是保持原先的滚动位置的办法"><a href="#七、vue-router-页面切换后保持在页面顶部而不是保持原先的滚动位置的办法" class="headerlink" title="七、vue-router 页面切换后保持在页面顶部而不是保持原先的滚动位置的办法"></a>七、vue-router 页面切换后保持在页面顶部而不是保持原先的滚动位置的办法</h4><p>vue-router有提供一个方法scrollBehavior，它可以使切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样。<br>这个功能只在 HTML5 history 模式下可用。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [...],</span><br><span class="line">  scrollBehavior (to, from, savedPosition) &#123;</span><br><span class="line">    // return 期望滚动到哪个的位置</span><br><span class="line">    if (savedPosition) &#123;</span><br><span class="line">        return savedPosition</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return &#123; x: 0, y: 0 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="八、vue关于父组件调用子组件的方法"><a href="#八、vue关于父组件调用子组件的方法" class="headerlink" title="八、vue关于父组件调用子组件的方法"></a>八、vue关于父组件调用子组件的方法</h4><blockquote><p>父组件： 在子组件中加上ref即可通过this.$refs.ref.method调用<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div @click=&quot;parentMethod&quot;&gt;</span><br><span class="line">    &lt;children ref=&quot;c1&quot;&gt;&lt;/children&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import children from &apos;components/children/children.vue&apos;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">      return &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      &apos;children&apos;: children</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">      parentMethod() &#123;</span><br><span class="line">        console.log(this.$refs.c1) //返回的是一个vue对象，所以可以直接调用其方法</span><br><span class="line">        this.$refs.c1.childMethod();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="九、关于Vue背景图打包之后访问路径错误问题"><a href="#九、关于Vue背景图打包之后访问路径错误问题" class="headerlink" title="九、关于Vue背景图打包之后访问路径错误问题"></a>九、关于Vue背景图打包之后访问路径错误问题</h4><p>通过vue-cli脚手架创建的vue项目，注意相对路径标识’./’,我们知道img为html标签，他的路径是由index.html开始访问的，他走./static/img/‘图片名’是能正确访问到图片的，所以img的路径没问题，然后app.css访问./static/img/‘图片名’是访问错误的，因为在css目录下并没有static目录。这样就造成了路径访问失败的问题。<br>解决办法：</p><blockquote><p>1.检查config文件中的assetsPublicPath是否设置为’/’而不是’./’ ,注意区分’/’为绝对路径，绝对路径从网站静态服务器根目录查询/static/img/图片，这样的路径就是正确的，如果设置为’./’，路径就变成了相对路径，相对路径会根据相对的文件目录来确定文件资源，会造成上面分析的问题<br>2.vue-cli创建的vue项目，会自带一个static目录，将出错图片放在该目录下面即可（正确解决办法） 查看vue-cli创建项目的webpack配置文件可以找到一个将static目录拷贝到dist目录中。根据对资源的规划不同，将需要打包的资源放在src/assets目录中，不需要打包的资源放入static目录中。</p></blockquote><h4 id="十、vue2绑定内联样式background的一些坑"><a href="#十、vue2绑定内联样式background的一些坑" class="headerlink" title="十、vue2绑定内联样式background的一些坑"></a>十、vue2绑定内联样式background的一些坑</h4><p>有一个需求是，给一个盒子添加一个背景图片，这个背景图片是动态请求回来的，那么应该怎么做？<br>正常情况下的vue内联样式如下写法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div :style=&quot;&#123; color: activeColor, fontSize: fontSize + &apos;px&apos; &#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  activeColor: &apos;red&apos;,</span><br><span class="line">  fontSize: 30</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时的style绑定的是一个JavaScript对象，在JavaScript中不允许出现 “-“ ，那么绑定一个背景图片应该这么写：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div :style=&quot;&#123;background: &apos;url(&apos;+ img +&apos;)&apos;，backgroundSize:cover &#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">data:&#123;</span><br><span class="line">  img:&apos;xxx.png&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将图片改为动态请求回来的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div :style=&quot;&#123;background: &apos;url(&apos;+ img +&apos;)&apos;，backgroundSize:cover &#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">data:&#123;</span><br><span class="line">    img:&apos;xxx.png&apos;</span><br><span class="line">&#125;,</span><br><span class="line">methods:&#123;</span><br><span class="line">// 伪代码 请求数据</span><br><span class="line">      getImg()&#123;</span><br><span class="line">        this.$http.get().then(function (e) &#123;</span><br><span class="line">          this.img = e.data //将数据赋值给img</span><br><span class="line">        &#125;.bind(this))</span><br><span class="line">      &#125;</span><br><span class="line">&#125;，</span><br><span class="line">created()&#123;</span><br><span class="line">// 调用函数</span><br><span class="line">    this.getImg()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为在生命周期 mounted 之前都是虚拟dom 也就是说 当页面已经渲染完，但是vue还没执行，所有数据丢失，此时我们加上<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div v-if=&apos;img &apos; :style=&quot;&#123;background: &apos;url(&apos;+ img +&apos;)&apos;，backgroundSize:cover &#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>表示有img属性的时候我们选择这个元素,至此就成功绑定背景图片了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一、使用vue-cli搭建项目&quot;&gt;&lt;a href=&quot;#一、使用vue-cli搭建项目&quot; class=&quot;headerlink&quot; title=&quot;一、使用vue-cli搭建项目&quot;&gt;&lt;/a&gt;一、使用vue-cli搭建项目&lt;/h4&gt;&lt;p&gt;1.安装vue-cli:安装好nod
      
    
    </summary>
    
      <category term="vue" scheme="chang229.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="chang229.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>js常见问题总结归纳</title>
    <link href="chang229.github.io/2018/02/28/js%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3/"/>
    <id>chang229.github.io/2018/02/28/js常见问题总结归纳/</id>
    <published>2018-02-28T06:08:08.000Z</published>
    <updated>2018-03-21T06:32:28.903Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、使用-typeof-bar-“object”-来确定-bar-是否是对象的潜在陷阱是什么？如何避免这个陷阱？"><a href="#一、使用-typeof-bar-“object”-来确定-bar-是否是对象的潜在陷阱是什么？如何避免这个陷阱？" class="headerlink" title="一、使用 typeof bar === “object” 来确定 bar 是否是对象的潜在陷阱是什么？如何避免这个陷阱？"></a>一、使用 typeof bar === “object” 来确定 bar 是否是对象的潜在陷阱是什么？如何避免这个陷阱？</h4><blockquote><p>首先<code>typeof bar === &quot;object&quot;</code>是检测<code>bar</code>是否是对象的可靠方法，但在javascript中<code>null</code>也被认为是对象，因此以下代码在控制台中将输出<code>true</code>:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var bar = null;</span><br><span class="line">console.log(typeof bar == &quot;object&quot;);</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>所以知道了<code>null</code>的问题，同时检测<code>bar</code>是否是<code>null</code>,就可以避免这一问题啦：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log((bar !== null) &amp;&amp; (typeof bar === &quot;object&quot;));</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>当<code>bar</code>是一个数组的时候，例如，当<code>var bar = []</code>的时候；在很多情况下，这是期望行为，因为数字是真正的对象，但如果你想数组也返回<code>false</code>时，可以修改上述方案：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log((bar !== null) &amp;&amp; (typeof bar === &quot;object&quot;) &amp;&amp; (toString.call(bar) !== &quot;[object Array]&quot;));</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="二、下面的代码将输出什么到控制台？为什么？"><a href="#二、下面的代码将输出什么到控制台？为什么？" class="headerlink" title="二、下面的代码将输出什么到控制台？为什么？"></a>二、下面的代码将输出什么到控制台？为什么？</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">    var a = b = 3;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">console.log(typeof a == &quot;undefined&quot;);</span><br><span class="line">console.log(typeof b == &quot;undefined&quot;);</span><br></pre></td></tr></table></figure><blockquote><p><code>var a = b = 3;</code>这句代码等同于：<code>b = 3; var a = b;</code>这时候变量<code>b</code>是不加<code>var</code>声明的变量，也就是全局变量，在函数内部没有<code>var</code>声明的变量是隐式全局变量。所以控制台打印的结果为：<code>true</code>和<code>false</code>。<br>如果再深入一步：在严格模式（使用<code>use strict</code>）,结果又会怎样？<br>在严格模式下运行的结果是：<code>报错:b is not undefined</code>;这正是严格模式的特点，避免不必要的<code>bug</code>(避免全局变量污染)。</p></blockquote><h4 id="三、关于this的指向问题，以下代码将会输出什么？"><a href="#三、关于this的指向问题，以下代码将会输出什么？" class="headerlink" title="三、关于this的指向问题，以下代码将会输出什么？"></a>三、关于<code>this</code>的指向问题，以下代码将会输出什么？</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var myObject = &#123;</span><br><span class="line">    foo:&quot;bar&quot;,</span><br><span class="line">    func:function()&#123;</span><br><span class="line">        var self = this;</span><br><span class="line">        console.log(this.foo);</span><br><span class="line">        console.log(self.foo);</span><br><span class="line">        (function()&#123;</span><br><span class="line">            console.log(this.foo);</span><br><span class="line">            console.log(self.foo);</span><br><span class="line">        &#125;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">myObject.func();</span><br></pre></td></tr></table></figure><blockquote><p>在外部函数中，<code>this</code>和<code>self</code>都是指向<code>myObject</code>,所以两者都可以正确的引用和访问<code>foo</code>,在内部函数中，<code>this</code>不再指向<code>myObject</code>，结果是<code>this.foo</code>没有在内部函数中被定义。在<code>ECMA5</code>之前，在内部函数中的<code>this</code>将指向全局的<code>window</code>对象；反之，因为作为<code>ECMA5</code>，内部函数中的功能<code>this</code>是未定义的。所以控制台将输出：<code>bar ;bar ;undefined ;bar ;</code></p></blockquote><h4 id="四、use-strict有什么意义和好处？"><a href="#四、use-strict有什么意义和好处？" class="headerlink" title="四、use strict有什么意义和好处？"></a>四、<code>use strict</code>有什么意义和好处？</h4><blockquote><p><code>use strict</code> 是一种在<code>JavaScript</code>代码运行时自动实行更严格解析和错误处理的方法。<br>严格模式的一些主要优点包括：</p></blockquote><p>1.使调试更加容易。那些被忽略或默默失败了的代码错误，会产生错误或抛出异常，因此尽早提醒你代码中的问题，你才能更快地指引到它们的源代码。</p><p>2.防止意外的全局变量。如果没有严格模式，将值分配给一个未声明的变量会自动创建该名称的全局变量。这是<code>JavaScript</code>中最常见的错误之一。在严格模式下，这样做的话会抛出错误。</p><p>3.消除<code>this</code>强制。如果没有严格模式，引用<code>null</code>或未定义的值到<code>this</code> 值会自动强制到全局变量。这可能会导致许多令人头痛的问题和让人恨不得拔自己头发的<code>bug</code>。在严格模式下，引用 <code>null</code>或未定义的<code>this</code>值会抛出错误。</p><p>4.不允许重复的属性名称或参数值。当检测到对象中重复命名的属性，例如：<br><code>var object = {foo: &quot;bar&quot;, foo: &quot;baz&quot;};</code>）<br>或检测到函数中重复命名的参数时,例如：<br><code>function foo(val1, val2, val1){}</code>）<br>严格模式会抛出错误，因此捕捉几乎可以肯定是代码中的bug可以避免浪费大量的跟踪时间。</p><p>5.使<code>eval()</code>更安全。在严格模式和非严格模式下，<code>eval()</code> 的行为方式有所不同。最显而易见的是，在严格模式下，变量和声明在<code>eval()</code> 语句内部的函数不会在包含范围内创建（它们会在非严格模式下的包含范围中被创建，这也是一个常见的问题源）。</p><p>6.在<code>delete</code>使用无效时抛出错误。<code>delete</code> 操作符（用于从对象中删除属性）不能用在对象不可配置的属性上。当试图删除一个不可配置的属性时，非严格代码将默默地失败，而严格模式将在这样的情况下抛出异常。</p><h4 id="五、小心javascript自动插入分号机制？看下面的代码，它们会返回什么？"><a href="#五、小心javascript自动插入分号机制？看下面的代码，它们会返回什么？" class="headerlink" title="五、小心javascript自动插入分号机制？看下面的代码，它们会返回什么？"></a>五、小心<code>javascript</code>自动插入分号机制？看下面的代码，它们会返回什么？</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo1()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        bar:&quot;hello&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">function foo2()&#123;</span><br><span class="line">    return</span><br><span class="line">        &#123;</span><br><span class="line">            bar:&quot;hello&quot;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;</span><br><span class="line">console.log(&quot;foo1 returns:&quot;);</span><br><span class="line">console.log(foo1());</span><br><span class="line">consoel.log(&quot;foo2 returns:&quot;);</span><br><span class="line">console.log(foo2());</span><br></pre></td></tr></table></figure><blockquote><p>以上代码将会打印出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foo1 returns:</span><br><span class="line">Object &#123;bar:&quot;hello&quot;&#125;</span><br><span class="line">foo2 returns:</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>原因是这样的，当碰到 <code>foo2()</code>中包含<code>return</code>语句的代码行（代码行上没有其他任何代码），分号会立即自动插入到返回语句之后。请仔细留意上面两个函数中<code>return</code>的不同之处，<code>foo2</code>函数的<code>return</code>是单独一行的。也不会抛出错误，因为代码的其余部分是完全有效的，即使它没有得到调用或做任何事情（相当于它就是是一个未使用的代码块，定义了等同于字符串<code>&quot;hello&quot;</code>的属性 <code>bar</code>）。所以，在使用<code>return</code>语句的时候，要留意<code>javascript</code>的这个特点，尽可能不要将<code>return</code>关键字写在独立的一行，避免不必造成不必要的错误。<br>在<code>《JavaScript语言精粹》</code>这本书里，这个“自动插入分号”机制被划入到了<code>JavaScript</code>的毒瘤里面，与之并列的前面的全局变量。</p></blockquote><h4 id="六、NaN是什么？如何测试一个值是否等于NaN？"><a href="#六、NaN是什么？如何测试一个值是否等于NaN？" class="headerlink" title="六、NaN是什么？如何测试一个值是否等于NaN？"></a>六、<code>NaN</code>是什么？如何测试一个值是否等于<code>NaN</code>？</h4><blockquote><p><code>NaN</code>属性代表一个“不是数字”的值。这个特殊的值是因为运算不能执行而导致的，不能执行的原因要么是因为其中的运算对象之一非数字。例如：<code>&quot;abc&quot; / 4</code>，要么是因为运算的结果非数字。例如：除数为零。虽然<code>NaN</code> 意味着“不是数字”，但是它的类型，不管你信不信，是<code>Number</code>：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(typeof NaN === &quot;number&quot;)   // true</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>此外， NaN 和任何东西比较，甚至是它自己本身，结果是false：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(NaN == NaN)   // false</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>一种半可靠的方法来测试一个数字是否等于<code>NaN</code>，是使用内置函数 <code>isNaN()</code>，但即使使用<code>isNaN()</code> 依然并非是一个完美的解决方案。<br>一个更好的解决办法是使用<code>value !== value</code>，如果值等于<code>NaN</code>，只会产生<code>true</code>。因为只有<code>NaN</code> 这货，才会自己不等于自己。<br>另外，<code>ES6</code>提供了一个新的<code>Number.isNaN()</code> 函数，这是一个不同的函数，并且比老的全局<code>isNaN()</code>函数更可靠。</p></blockquote><h4 id="七、以下代码的运行结果是什么？"><a href="#七、以下代码的运行结果是什么？" class="headerlink" title="七、以下代码的运行结果是什么？"></a>七、以下代码的运行结果是什么？</h4><p>1.<code>console.log(1 + &quot;2&quot; + &quot;2&quot;);   // &quot;122&quot;;</code></p><p>2.<code>console.log(1 + +&quot;2&quot; + &quot;2&quot;);  // &quot;32&quot;;</code></p><blockquote><p>根据运算的顺序，要执行的第一个运算是<code>+&quot;2&quot;</code>（第一个<code>&quot;2&quot;</code>前面的额外 <code>+</code>被视为一元运算符），因此，<code>JavaScript</code>将<code>&quot;2&quot;</code> 的类型转换为数字，然后应用一元 + 号（即将其视为一个正数）。其结果就是得到一个数字<code>2</code>。</p></blockquote><p>3.<code>console.log(1 + -&quot;1&quot; + &quot;2&quot;);  // &quot;02&quot;;</code></p><p>4.<code>console.log(+&quot;1&quot; + &quot;1&quot; + &quot;2&quot;);   // &quot;112&quot;;</code></p><p>5.<code>console.log(&quot;a&quot; - &quot;b&quot; + &quot;2&quot;);    // &quot;NaN2&quot;;</code></p><p>6.<code>console.log(&quot;a&quot; - &quot;b&quot; + 2);     // NaN;</code></p><h4 id="八、关于逻辑运算符，下面代码的运行结果是什么？"><a href="#八、关于逻辑运算符，下面代码的运行结果是什么？" class="headerlink" title="八、关于逻辑运算符，下面代码的运行结果是什么？"></a>八、关于逻辑运算符，下面代码的运行结果是什么？</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log( 0 || 1);   // 1;</span><br><span class="line">console.log( 1 || 2);   // 1;</span><br><span class="line">console.log( 0 &amp;&amp; 1);   // 0;</span><br><span class="line">console.log( 1 &amp;&amp; 2);   // 2;</span><br></pre></td></tr></table></figure><blockquote><p>在<code>JavaScript</code>中， <code>||</code> 和 <code>&amp;&amp;</code> 都是逻辑运算符，用于在从左至右计算时，返回第一个可完全确定的“逻辑值”。</p></blockquote><h4 id="九、以下代码输出的结果是什么？为什么？"><a href="#九、以下代码输出的结果是什么？为什么？" class="headerlink" title="九、以下代码输出的结果是什么？为什么？"></a>九、以下代码输出的结果是什么？为什么？</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = &#123;&#125;,</span><br><span class="line">    b = &#123;key:&quot;b&quot;&#125;,</span><br><span class="line">    c = &#123;key:&quot;c&quot;&#125;;</span><br><span class="line">a[b] = 123;</span><br><span class="line">a[c] = 456;</span><br><span class="line">console.log(a[b]);</span><br></pre></td></tr></table></figure><blockquote><p>JavaScript在设置对象的属性的时候，会暗中字符串化参数值；在以上代码中b和c都是对象，把它们设置为对象a的参数，它们都将被转换为 “[object Object]”, 所以a[b]和a[c]都相当于a[‘object Object’];所以a[c]会将a[b]的值覆盖掉，因此，设置或引用 a[c] 和设置或引用 a[b] 完全相同。所以得到的答案是  456  ；</p></blockquote><h4 id="十、说明以下代码的异同？"><a href="#十、说明以下代码的异同？" class="headerlink" title="十、说明以下代码的异同？"></a>十、说明以下代码的异同？</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">line-height:15px;</span><br><span class="line">line-height:150%;</span><br><span class="line">line-height:1.5;</span><br><span class="line">line-height:1.5em;</span><br></pre></td></tr></table></figure><blockquote><p>行高为150%时，会根据父元素的字体大小先计算出行高值然后再让子元素继承。所以当line-height:150%时，子元素的行高等于<code>父元素的fontSize值 * 150%</code>;<br>当line-height:1.5em时，会根据父元素的字体大小先计算出行高值然后再让子元素继承。所以当line-height:1.5em时，子元素的行高等于<code>父元素的fontSize值 * 1.5em</code>;<br>当line-height:1.5时，会根据子元素的字体大小动态计算出行高值让子元素继承。所以，当line-height:1.5时，子元素行高等于<code>子元素的fontSize值 * 1.5 = 45px</code>;如果没有子元素，则以自身的fontSize值为准。</p></blockquote><h4 id="十一、关于this指向，以下代码将输出什么？"><a href="#十一、关于this指向，以下代码将输出什么？" class="headerlink" title="十一、关于this指向，以下代码将输出什么？"></a>十一、关于this指向，以下代码将输出什么？</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    _name: &apos;I am John&apos;,</span><br><span class="line">    sayHello: function ()&#123;</span><br><span class="line">        return this._name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var sayHello = person.sayHello;</span><br><span class="line"></span><br><span class="line">console.log(sayHello());</span><br><span class="line">console.log(person.sayHello());</span><br></pre></td></tr></table></figure><p>代码运行的结果是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">undefined</span><br><span class="line">I am John</span><br></pre></td></tr></table></figure></p><blockquote><p>在执行<code>sayHello()</code>的时候，当访问到<code>this._name</code>时，此时的<code>this</code>已经不再是<code>person</code> 对象，而是全局窗口对象，也就是<code>widnow</code>对象。与此同时，<code>widnow</code>对象并不存在<code>_name</code>属性，所以返回的是<code>undefined</code>。</p></blockquote><h4 id="十二、关于变量提升，以下代码将输出什么？看下面的代码，输出的结果是什么？并解释你的答案。"><a href="#十二、关于变量提升，以下代码将输出什么？看下面的代码，输出的结果是什么？并解释你的答案。" class="headerlink" title="十二、关于变量提升，以下代码将输出什么？看下面的代码，输出的结果是什么？并解释你的答案。"></a>十二、关于变量提升，以下代码将输出什么？看下面的代码，输出的结果是什么？并解释你的答案。</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">   console.log(a);</span><br><span class="line">   console.log(foo());</span><br><span class="line"></span><br><span class="line">   var a = 1;</span><br><span class="line">   function foo() &#123;</span><br><span class="line">      return 2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();//输出的结果是什么？</span><br></pre></td></tr></table></figure><blockquote><p>这段代码的执行结果是<code>undefined</code>和<code>2</code>。</p></blockquote><p>原因是：js代码在执行之前都有预解析，预解析的时候<code>var</code>声明的变量和函数声明都被提升到了函数体的顶部。但是<code>var</code>声明的变量的提升只提升变量名不提升赋值。所以上面的代码相当于：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">   var a;//提升到执行环境顶部</span><br><span class="line">   function foo() &#123;</span><br><span class="line">      return 2;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   console.log(a);</span><br><span class="line">   console.log(foo());</span><br><span class="line"></span><br><span class="line">   a = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一、使用-typeof-bar-“object”-来确定-bar-是否是对象的潜在陷阱是什么？如何避免这个陷阱？&quot;&gt;&lt;a href=&quot;#一、使用-typeof-bar-“object”-来确定-bar-是否是对象的潜在陷阱是什么？如何避免这个陷阱？&quot; class=
      
    
    </summary>
    
      <category term="js" scheme="chang229.github.io/categories/js/"/>
    
    
      <category term="js" scheme="chang229.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>JS中判断对象是不是数组的方法</title>
    <link href="chang229.github.io/2018/02/02/JS%E4%B8%AD%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%B8%8D%E6%98%AF%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>chang229.github.io/2018/02/02/JS中判断对象是不是数组的方法/</id>
    <published>2018-02-02T01:57:40.000Z</published>
    <updated>2018-03-21T06:32:20.975Z</updated>
    
    <content type="html"><![CDATA[<p>今天有同事突然问到如何判断一个对象是不是数组，当时只想到啦<code>instanceof</code>操作符，后来又搜集了一些文章，总结出以下方法。</p><h4 id="一、typeof-操作符"><a href="#一、typeof-操作符" class="headerlink" title="一、typeof 操作符"></a>一、typeof 操作符</h4><p>在js中使用<code>typeof</code>操作符来判断<code>function string number boolean undefined</code>等是没有问题的。但是如果要检测Array就没有作用了，因为<code>typeof</code>判断<code>array</code>和<code>null</code>的结果都是<code>object</code>。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alert(typeof null); // &quot;object&quot;</span><br><span class="line">alert(typeof function () &#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125;); // &quot;function&quot;</span><br><span class="line">alert(typeof &apos;abcd&apos;); // &quot;string&quot;</span><br><span class="line">alert(typeof true); //boolean</span><br><span class="line">alert(typeof 1); // &quot;number&quot;</span><br><span class="line">alert(typeof a); // &quot;undefined&quot;</span><br><span class="line">alert(typeof undefined); // &quot;undefined&quot;</span><br><span class="line">alert(typeof []); // &quot;object&quot;</span><br></pre></td></tr></table></figure></p><h4 id="二、instanceof-操作符"><a href="#二、instanceof-操作符" class="headerlink" title="二、instanceof 操作符"></a>二、instanceof 操作符</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr = [];</span><br><span class="line">console.log(arr instanceof Array);</span><br></pre></td></tr></table></figure><p><code>arr instanceof Array</code>的含义是：判断<code>Array</code>的<code>prorotype</code>属性是不是在<code>arr</code>的原型链上，是返回<code>true</code>,否返回<code>false</code>;</p><h4 id="三、对象的constructor属性"><a href="#三、对象的constructor属性" class="headerlink" title="三、对象的constructor属性"></a>三、对象的constructor属性</h4><p>除了instanceof，每个对象还有constructor的属性，利用它似乎也能进行Array的判断<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr = [];</span><br><span class="line">console.log(arr.constructor === Array);</span><br></pre></td></tr></table></figure></p><h4 id="四、instanceof-和-constructor-的缺陷"><a href="#四、instanceof-和-constructor-的缺陷" class="headerlink" title="四、instanceof 和 constructor 的缺陷"></a>四、instanceof 和 constructor 的缺陷</h4><p>通过使用 instanceof 和 constructor 来判断对象是不是数组，在大多数情况下是可以的，但实际上也还是有缺陷的，当页面上有多个<code>frame</code>,需要在多个iframe中来回切换时，这种方法的缺陷就表现出来啦。</p><blockquote><p>由于每个iframe都有一套自己的执行环境，跨frame实例化的对象彼此是不共享原型链的，因此导致<code>instanceof</code>和<code>constructor</code>失效。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var iframe = document.createElement(&apos;iframe&apos;); //创建iframe</span><br><span class="line">document.body.appendChild(iframe); //添加到body中</span><br><span class="line">xArray = window.frames[window.frames.length-1].Array;</span><br><span class="line">var arr = new xArray(1,2,3); // 声明数组[1,2,3]</span><br><span class="line">alert(arr instanceof Array); // false</span><br><span class="line">alert(arr.constructor === Array); // false</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="五、Object-prototype-toString"><a href="#五、Object-prototype-toString" class="headerlink" title="五、Object.prototype.toString"></a>五、Object.prototype.toString</h4><p>Object.prototype.toString的行为：首先，取得对象的一个内部属性[[Class]]，然后依据这个属性，返回一个类似于”[object Array]”的字符串作为结果(看过ECMA标准的应该都知道，[[]]用来表示语言内部用到的、外部不可直接访问的属性，称为“内部属性”)。利用这 个方法，再配合call，我们可以取得任何对象的内部属性[[Class]]，然后把类型检测转化为字符串比较，以达到我们的目的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function isArrayFn (o) &#123;</span><br><span class="line">return Object.prototype.toString.call(o) === &apos;[object Array]&apos;;</span><br><span class="line">&#125;</span><br><span class="line">var arr = [1,2,3,1];</span><br><span class="line">alert(isArrayFn(arr));// true</span><br></pre></td></tr></table></figure><p>call改变toString的this引用为待检测的对象，返回此对象的字符串表示，然后对比此字符串是否是’[object Array]’，以判断其是否是Array的实例。为什么不直接o.toString()?嗯，虽然Array继承自Object，也会有 toString方法，但是这个方法有可能会被改写而达不到我们的要求，而Object.prototype则是老虎的屁股，很少有人敢去碰它的，所以能一定程度保证其“纯洁性”：)</p><p>JavaScript 标准文档中定义: [[Class]] 的值只可能是下面字符串中的一个： Arguments, Array, Boolean, Date, Error, Function, JSON, Math, Number, Object, RegExp, String.<br>这种方法在识别内置对象时往往十分有用，但对于自定义对象请不要使用这种方法。</p><h4 id="六、Array-isArray"><a href="#六、Array-isArray" class="headerlink" title="六、Array.isArray()"></a>六、Array.isArray()</h4><p>ECMAScript5中引入了Array.isArray()方法，用于专门判断一个对象是不是数组，是返回<code>true</code>，不是返回<code>false</code>;目前所有主流浏览器和IE9+都对其进行了支持，IE8及以下浏览器不支持该方法。</p><h4 id="七、一种最佳的判断方法"><a href="#七、一种最佳的判断方法" class="headerlink" title="七、一种最佳的判断方法"></a>七、一种最佳的判断方法</h4><p>综合以上方法的优缺点，可以有一个最佳的判断数组的写法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr = [1,2,3,1];</span><br><span class="line">var arr2 = [&#123; abac : 1, abc : 2 &#125;];</span><br><span class="line">function isArrayFn(value)&#123;</span><br><span class="line">    if (typeof Array.isArray === &quot;function&quot;) &#123;</span><br><span class="line">        return Array.isArray(value);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return Object.prototype.toString.call(value) === &quot;[object Array]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(isArrayFn(arr));// true</span><br><span class="line">console.log(isArrayFn(arr2));// true</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天有同事突然问到如何判断一个对象是不是数组，当时只想到啦&lt;code&gt;instanceof&lt;/code&gt;操作符，后来又搜集了一些文章，总结出以下方法。&lt;/p&gt;
&lt;h4 id=&quot;一、typeof-操作符&quot;&gt;&lt;a href=&quot;#一、typeof-操作符&quot; class=&quot;head
      
    
    </summary>
    
      <category term="js" scheme="chang229.github.io/categories/js/"/>
    
    
      <category term="js" scheme="chang229.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>2018年你应该了解的前端新技术</title>
    <link href="chang229.github.io/2018/01/21/2018%E5%B9%B4%E4%BD%A0%E5%BA%94%E8%AF%A5%E4%BA%86%E8%A7%A3%E7%9A%84%E5%89%8D%E7%AB%AF%E6%96%B0%E6%8A%80%E6%9C%AF/"/>
    <id>chang229.github.io/2018/01/21/2018年你应该了解的前端新技术/</id>
    <published>2018-01-21T06:08:51.000Z</published>
    <updated>2018-03-21T06:32:11.904Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、HTML5-2新标签dialog"><a href="#一、HTML5-2新标签dialog" class="headerlink" title="一、HTML5.2新标签dialog"></a>一、HTML5.2新标签dialog</h4><p>HTMl5.2新的版本出现了一个有意思的标签，那就是对话窗或窗口，也就是<code>dialog</code>,其基本用法如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dialog open&gt;</span><br><span class="line">    //soming...</span><br><span class="line">&lt;/dialog&gt;</span><br></pre></td></tr></table></figure></p><blockquote><p><code>open</code>属性表明该窗口是默认显示的，用户可与之交互。<br>相关js方法有：<br>1.<code>close()</code>:关闭对话框，可选传入类型为{domxref(“DOMString”)}}的参数，用来更新对话框的returnValue。<br>2.<code>open()</code>:非模式化的显示这个对话框, 即：打开这个对话框之后依然可以和其他内容进行交互。 可选传入类型为<code>Element</code>或者<code>MouseEvent</code>的参数，用来定义对话框的显示位置。<br>3.<code>showModal()</code>:模式化的显示这个对话框， 并且将会至于所有其他对话框的顶层（屏蔽其他对话框的交互）。 可选传入类型为<code>Element</code>或者<code>MouseEvent</code>的参数， 用来定义对话框的显示位置。<br><code>show()</code>和<code>showModal()</code>是有区别的，<code>show</code>只是显示<code>dialog</code>,而<code>showMadal()</code>是会屏蔽其他的弹出层。<br>按<code>ESC</code>可以关闭<code>dialog</code>，<code>dialog</code>需要重新定义<code>css</code>样式，毕竟本身<code>css</code>是默认的样式。<br>下面是一个demo代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 创建一个dialog --&gt;</span><br><span class="line">&lt;dialog&gt;</span><br><span class="line">    &lt;h1&gt;这是dialog的标题&lt;/h1&gt;</span><br><span class="line">    &lt;div&gt;这是dialog的内容&lt;/div&gt;</span><br><span class="line">    &lt;button id=&quot;close_dialog&quot;&gt;关闭&lt;/button&gt;</span><br><span class="line">&lt;/dialog&gt;</span><br><span class="line">&lt;button id=&quot;open_dialog&quot;&gt;打开&lt;/button&gt;</span><br><span class="line">&lt;!-- js代码 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var dialog = document.getElementsByTagName(&quot;dialog&quot;)[0],</span><br><span class="line">        openDialog = document.getElementById(&quot;open_dialog&quot;),</span><br><span class="line">        closeDialog = document.getElementById(&quot;close_dialog&quot;);</span><br><span class="line">    openDialog.onclick = function()&#123;</span><br><span class="line">        dialog.showModal();</span><br><span class="line">    &#125;;</span><br><span class="line">    closeDialog.onclick = function()&#123;</span><br><span class="line">        dialog.close();</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="二、Grid布局全新的css网站布局"><a href="#二、Grid布局全新的css网站布局" class="headerlink" title="二、Grid布局全新的css网站布局"></a>二、Grid布局全新的css网站布局</h4><p>CSS Grid 布局由两个核心组成部分是 wrapper（父元素）和 items（子元素）。 wrapper 是实际的 grid(网格)，items 是 grid(网格) 内的内容。下面是一个 wrapper 元素，内部包含6个 items ：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;wrapper&quot;&gt;</span><br><span class="line">    &lt;div&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;2&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;3&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;4&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;5&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;6&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>要把 wrapper 元素变成一个<code>grid(网格)</code>，只要简单地把其 <code>display</code> 属性设置为<code>grid</code>即可：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.wrapper&#123;</span><br><span class="line">    displau:grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了使其成为二维的网格容器，我们需要定义列和行。让我们创建3列和2行。我们将使用<code>grid-template-row</code>和<code>grid-template-column</code>属性。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.wrapper&#123;</span><br><span class="line">    display:grid;</span><br><span class="line">    grid-template-columns:100px 100px 100px;</span><br><span class="line">    grid-template-rows:50px 50px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>正如你所看到的，我们为<code>grid-template-columns</code>写入了 3 个值，这样我们就会得到 3 列。 我们想要得到 2 行，因此我们为 <code>grid-template-rows</code>指定了2个值。<br>这些值决定了我们希望我们的列有多宽（ 100px ），以及我们希望行数是多高（ 50px ）,结果如下：<br><img src="http://newimg88.b0.upaiyun.com/newimg88/2017/12/1_fJNIdDiScjhI9CZjdxv3Eg.png" alt="我是图片"><br>接下来是如何在 grid(网格) 上放置 items(子元素) 。特别注意，这里才是体现 Grid 布局超能力的地方，因为它使得创建布局变得非常简单。<br>我们使用与之前相同的 HTML 标记，为了帮助我们更好的理解，我们在每个 items(子元素) 加上了单独的 class ：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;wrapper&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;item1&quot;&gt;1&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;item2&quot;&gt;2&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;item3&quot;&gt;3&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;item4&quot;&gt;4&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;item5&quot;&gt;5&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;item6&quot;&gt;6&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>现在，我们来创建一个 3×3 的 grid(网格)：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.wrapper &#123;</span><br><span class="line">    display: grid;</span><br><span class="line">    grid-template-columns: 100px 100px 100px;</span><br><span class="line">    grid-template-rows: 100px 100px 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将得到以下布局：<br><img src="http://newimg88.b0.upaiyun.com/newimg88/2017/12/1_WxIT0z8OH7-rkoFMg5fwRw.png" alt="3*3布局"><br>不知道你发现没有，我们只在页面上看到 3×2 的 grid(网格)，而我们定义的是 3×3 的 grid(网格)。这是因为我们只有 6 个 items(子元素) 来填满这个网格。如果我们再加3个 items(子元素)，那么最后一行也会被填满。</p><p>要定位和调整 items(子元素) 大小，我们将使用<code>grid-column</code>和 <code>grid-row</code>属性来设置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.item1 &#123;</span><br><span class="line">    grid-column-start: 1;</span><br><span class="line">    grid-column-end: 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们在这里要做的是，我们希望 item1 占据从第一条网格线开始，到第四条网格线结束。换句话说，它将独立占据整行。 以下是在屏幕上显示的内容：<br><img src="http://newimg88.b0.upaiyun.com/newimg88/2017/12/1_he7CoAzdQB3sei_WpHOtNg.png" alt="布局图片"><br>如果你不明白我们设置的只有 3 列，为什么有4条网格线呢？看看下面这个图像，我画了黑色的列网格线：<br><img src="http://newimg88.b0.upaiyun.com/newimg88/2017/12/1_l-adYpQCGve7W6DWY949pw.png" alt="布局网格线"><br>请注意，我们现在正在使用网格中的所有行。当我们把第一个 items(子元素) 占据整个第一行时，它把剩下的 items(子元素) 都推到了下一行。<br>最后，给你一个更简单的缩写方法来编写上面的语法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.item1 &#123;</span><br><span class="line">    grid-column: 1 / 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了确保你已经正确理解了这个概念，我们重新排列其他的 items(子元素) 。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.item1 &#123;</span><br><span class="line">    grid-column-start: 1;</span><br><span class="line">    grid-column-end: 3;</span><br><span class="line">&#125;</span><br><span class="line">.item3 &#123;</span><br><span class="line">    grid-row-start: 2;</span><br><span class="line">    grid-row-end: 4;</span><br><span class="line">&#125;</span><br><span class="line">.item4 &#123;</span><br><span class="line">    grid-column-start: 2;</span><br><span class="line">    grid-column-end: 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以下是页面上的布局效果：<br><img src="http://newimg88.b0.upaiyun.com/newimg88/2017/12/1_QDSybpxjXSat6UtoHgUapQ.png" alt="布局效果"></p><h4 id="三、Parcel：超快的Web应用打包器"><a href="#三、Parcel：超快的Web应用打包器" class="headerlink" title="三、Parcel：超快的Web应用打包器"></a>三、Parcel：超快的Web应用打包器</h4><p>虽然 webpack 带来了许多可配置性，同事也造就了它的复杂性。 而 Parcel 带来简单性。 官方号称 Parcel 为 “零配置” ，开箱即用。</p><p>正如上面所说的 – Parcel 内置了一个开箱即用的开发服务器。 开发服务器将在你更改文件时自动重新构建你的应用程序，并支持<code>模块热替换</code>以实现快速开发。<br>Parcel 有什么好处？<br>1.快速打包 – Parcel 比 Webpack，Rollup 和 Browserify 更快。<br>2.Parcel 支持 JS、CSS、HTML、资源文件等等 – 无需插件 – 更加便于用户使用。<br>3.零配置。开箱即用的代码拆分，模块热替换，CSS 预处理器，开发服务器，缓存等等；<br>4.更加友好的错误日志。<br>我们应该什么时候使用 Parcel ， Webpack 或 Rollup 呢？<br>这完全取决于你，但我个人会在以下情况下使用每个打包器：<br>Parcel：中小型项目（代码行小于 15k）<br>Webpack：大型以及企业级项目。<br>Rollup：用于 NPM 包。<br>让我们给 Parcel 一个机会 。<br>Parcel官网地址：*<a href="https://parceljs.org/" target="_blank" rel="noopener">https://parceljs.org/</a></p><h4 id="四、PWA是否能带来新一轮大前端技术洗牌？"><a href="#四、PWA是否能带来新一轮大前端技术洗牌？" class="headerlink" title="四、PWA是否能带来新一轮大前端技术洗牌？"></a>四、PWA是否能带来新一轮大前端技术洗牌？</h4><p>渐进式网络应用 ( Progressive Web Apps )，即我们所熟知的 PWA。<br>自 2015 年以来，PWA 相关的技术不断升级优化，在用户体验和用户留存两方面都提供了非常好的解决方案。PWA 可以将 Web 和 App 各自的优势融合在一起：渐进式、可响应、可离线、实现类似 App 的交互、即时更新、安全、可以被搜索引擎检索、可推送、可安装、可链接。<br>PWA 不是特指某一项技术，而是应用了多项技术的 Web App。其核心技术包括 App Manifest、Service Worker、Web Push、Credential Management API ，等等。其核心目标就是提升 Web App 的性能，改善 Web App 的用户体验。<br>下面我们详细地看一下这些核心技术，是否能够真正弥补 Web 劣势。</p><ol><li>Web App Manifest<blockquote><p>Web App Manifest 是为了解决用户留存问题而诞生的，它是一个外链的 JSON 文件，在这个文件中，像浏览器暴露了站点的名称，地址，图标等等元数据。在浏览器中通过 <link rel="manifest" href="/manifest.json"> 引入这个 JSON 文件，浏览器识别到这个文件的存在，会根据自己的机制决定是否弹出添加到桌面对话框，并在桌面上生成一个应用的图标，通过点击桌面图标进入应用具有沉浸式的体验，全屏显示，没有浏览器地址栏，并且还会自动添加应用启动画面。</p></blockquote></li><li>Service Worker<blockquote><p>Service Worker 是一个特殊的 Web Worker，独立于页面主线程运行，它能够拦截和处理网络请求，并且配合 Cache Storage API，开发者可以自由的对页面发送的 HTTP 请求进行管理，这就是为什么 Service Worker 能让 Web 站点离线的原因。</p></blockquote></li><li>Push Notification<blockquote><p>Push Notification 其实是两个 API 的结合， Notification API 和 Push API 。<br>Notification API 提供了开发者可以给用户发送通知的能力，包括申请显示通知权限，发起通知，以及定制通知的类型等等。<br>Push API，则是让服务器能够向用户发送离线消息，即使用户当前并没有打开你的页面，甚至没有打开浏览器。</p></blockquote></li></ol><p>各家浏览器厂商在 2017 年开始大力支持 PWA,连苹果都已经在几个月前悄悄的进行了 Service Worker 的开发了，iOS 也将支持 PWA。各大站点纷纷实践，用 PWA 已成趋势。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一、HTML5-2新标签dialog&quot;&gt;&lt;a href=&quot;#一、HTML5-2新标签dialog&quot; class=&quot;headerlink&quot; title=&quot;一、HTML5.2新标签dialog&quot;&gt;&lt;/a&gt;一、HTML5.2新标签dialog&lt;/h4&gt;&lt;p&gt;HTMl5.
      
    
    </summary>
    
      <category term="js" scheme="chang229.github.io/categories/js/"/>
    
    
      <category term="js" scheme="chang229.github.io/tags/js/"/>
    
  </entry>
  
</feed>
